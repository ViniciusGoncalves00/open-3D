{
  "name": "assets",
  "children": [
    {
      "name": "components",
      "children": [
        {
          "name": "component.ts",
          "content": "import { IObserver } from \"../../common/patterns/observer/observer\";\n\nexport abstract class Component {\n    public enabled: boolean = true;\n    public abstract clone(): Component;\n    public abstract copyFrom(component: Component): void;\n    public abstract toJSON(): any;\n    public abstract fromJSON(json: any): void;\n    public abstract destroy(): void;\n\n    private observers: IObserver[] = [];\n\n    public attach(observer: IObserver): void {\n        this.observers.push(observer);\n      }\n    \n    public dettach(observer: IObserver): void {\n      const index = this.observers.indexOf(observer);\n      if (index === -1) return;\n      this.observers.splice(index, 1);\n    }\n}"
        },
        {
          "name": "directional-light.ts",
          "content": "import { Vector3 } from \"../../core/api/vector3\";\nimport { Component } from \"./component\";\nimport { Light } from \"./light\";\n\nexport class DirectionalLight extends Light {\n    public fromJSON(json: any): void {\n        throw new Error(\"Method not implemented.\");\n    }\n    private readonly _direction: Vector3;\n    public get direction(): Vector3 { return this._direction; }\n\n    public constructor(color: string = \"0xffffff\", intensity: number = 1.0, direction: Vector3 = new Vector3(0, 0, 0)) {\n        super(color, intensity);\n\n        this._direction = direction;\n    }\n\n    public clone(): DirectionalLight {\n        throw new Error(\"Method not implemented.\");\n    }\n    public copyFrom(component: DirectionalLight): void {\n        throw new Error(\"Method not implemented.\");\n    }\n    public toJSON() {\n        throw new Error(\"Method not implemented.\");\n    }\n    public destroy(): void {}\n}"
        },
        {
          "name": "light.ts",
          "content": "import { Component } from \"./component\";\n\n/**\n* Abstract base class for lights.\n*/\nexport abstract class Light extends Component {\n    private _color: string;\n    private _intensity: number = 1.0;\n\n    /**\n    * @param color Light color (default: \"0xffffff\")\n    * @param intensity Light intensity (default: 1.0)\n    */\n    public constructor(color: string = \"0xffffff\", intensity: number = 1.0) {\n        super();\n\n        this._color = color;\n        this._intensity = intensity;\n    }\n}"
        },
        {
          "name": "mesh.ts",
          "content": "import { ObservableField } from \"../../common/patterns/observer/observable-field\";\nimport { ObservableList } from \"../../common/patterns/observer/observable-list\";\nimport { Vector3 } from \"../../core/api/vector3\";\nimport { Component } from \"./component\";\n\nexport class Mesh extends Component {\n  private readonly _name: ObservableField<string>;\n  public get name(): ObservableField<string> { return this._name; }\n\n  private readonly _vertices: ObservableList<Vector3>;\n  public get vertices(): ObservableList<Vector3> { return this._vertices; }\n    \n  private readonly _indices: ObservableList<ObservableField<number>>;\n  public get indices(): ObservableList<ObservableField<number>> { return this._indices; }\n\n  constructor(\n    name = \"name\",\n    vertices = [new Vector3(0, 0, 0), new Vector3(0, 0, 1), new Vector3(1, 0, 0)],\n    indices = [new ObservableField(0), new ObservableField(1), new ObservableField(2)]\n  ) {\n    super();\n    this._name = new ObservableField(name);\n    this._vertices = new ObservableList(vertices);\n    this._indices = new ObservableList(indices);\n  }\n\n  public clone(): Mesh {\n    const clone = new Mesh(\n      this._name.value,\n      this._vertices.items,\n      this._indices.items,\n    );\n    \n    clone.enabled = this.enabled;\n    return clone;\n  }\n\n  public copyFrom(mesh: Mesh): void {\n    this._name.value = mesh._name.value;\n    this._vertices.clear();\n    mesh._vertices.items.forEach(item => this._vertices.add(item));\n    this._indices.clear();\n    mesh._indices.items.forEach(item => this._indices.add(item));\n    this.enabled = mesh.enabled;\n  }\n\n  public toJSON() {\n    return {\n      enabled: this.enabled,\n      name: this._name.value,\n      vertices: this._vertices.items.map(v => ({\n        x: v.x.value,\n        y: v.y.value,\n        z: v.z.value,\n      })),\n      indices: this._indices.items.map(i => i.value),\n    };\n  }\n\n  public fromJSON(json: any): void {\n    this.enabled = json.enabled;\n    this._name.value = json.name;\n\n    this._vertices.clear();\n    for (const v of json.vertices) {\n      this._vertices.add(new Vector3(v.x, v.y, v.z));\n    }\n\n    this._indices.clear();\n    for (const i of json.indices) {\n      this._indices.add(new ObservableField<number>(i));\n    }\n  }\n\n  public destroy(): void {}\n}"
        },
        {
          "name": "orbit.ts",
          "content": "import { ObservableField } from \"../../common/patterns/observer/observable-field\";\nimport { Vector3 } from \"../../core/api/vector3\";\nimport { Component } from \"./component\";\n\nexport class Orbit extends Component {\n  public fromJSON(json: any): void {\n    throw new Error(\"Method not implemented.\");\n  }\n  private readonly _center: Vector3;\n  public get center(): Vector3 { return this._center; }\n\n  private readonly _distance: ObservableField<number>;\n  public get distance(): ObservableField<number> { return this._distance; }\n\n  private readonly _speed: ObservableField<number>;\n  public get speed(): ObservableField<number> { return this._speed; }\n\n  private readonly _axis: Vector3;\n  public get axis(): Vector3 { return this._axis; }\n\n  public readonly _angle: ObservableField<number> = new ObservableField<number>(0);\n  public get angle(): ObservableField<number> { return this._angle; }\n\n  constructor(\n    center: Vector3 = new Vector3(0, 0, 0),\n    distance: ObservableField<number> = new ObservableField<number>(1),\n    speed: ObservableField<number> = new ObservableField<number>(1),\n    axis: Vector3 = new Vector3(0, 1, 0)\n  ) {\n    super();\n    this._center = center;\n    this._distance = distance;\n    this._speed = speed;\n    this._axis = axis;\n  }\n\n  public clone(): Orbit {\n    const clone = new Orbit(\n      this._center.clone(),\n      this._distance,\n      this._speed,\n      this._axis.clone()\n    );\n    clone.angle.value = this.angle.value;\n    clone.enabled = this.enabled;\n    return clone;\n  }\n\n  public copyFrom(orbit: Orbit): void {\n      this._center.set(orbit.center.x.value, orbit.center.y.value, orbit.center.z.value);\n      this._axis.set(orbit.axis.x.value, orbit.axis.y.value, orbit.axis.z.value);\n      this._distance.value = orbit.distance.value;\n      this._speed.value = orbit.speed.value;\n  }\n\n  public toJSON() {\n    throw new Error(\"Method not implemented.\");\n  }\n  \n  public destroy(): void {}\n}"
        },
        {
          "name": "rotate.ts",
          "content": "import { Component } from \"./component\";\nimport { Vector3 } from \"../../core/api/vector3\";\nimport { ObservableField } from \"../../common/patterns/observer/observable-field\";\n\nexport class Rotate extends Component {\n  public fromJSON(json: any): void {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  private readonly _axis: Vector3;\n  public get axis(): Vector3 { return this._axis; }\n\n  private readonly _speed: ObservableField<number>;\n  public get speed(): ObservableField<number> { return this._speed; }\n\n  constructor(axis: Vector3 = new Vector3(0, 0, 0), speed: ObservableField<number> = new ObservableField<number>(1)) {\n    super();\n    this._axis = axis;\n    this._speed = speed;\n  }\n\n  public clone(): Rotate {\n    const clonedAxis = new Vector3(this._axis.x.value, this._axis.y.value, this._axis.z.value);\n    const clone = new Rotate(clonedAxis, this._speed);\n    clone.enabled = this.enabled;\n    return clone;\n  }\n\n  public copyFrom(rotate: Rotate): void {\n      this._axis.set(rotate.axis.x.value, rotate.axis.y.value, rotate.axis.z.value);\n      this._speed.value = rotate.speed.value;\n  }\n\n  public toJSON() {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  public destroy(): void {}\n}"
        },
        {
          "name": "transform.ts",
          "content": "import { Component } from \"./component\";\nimport { Vector3 } from \"../../core/api/vector3\";\nimport { mat4 as matrix4 } from \"gl-matrix\";\nimport { vec3 as vector3 } from \"gl-matrix\";\nimport { quat as quaternion } from \"gl-matrix\";\nimport { ObservableMatrix4 } from \"../../common/patterns/observer/observable-matrix4\";\nimport { Entity } from \"../../core/api/entity\";\n\nexport class Transform extends Component {\n  public readonly owner: Entity;\n\n  private _parent: Entity | null = null;\n  public get parent(): Entity | null {\n    return this._parent;\n  }\n\n  public set parent(newParent: Entity | null) {\n    if(newParent?.id === this._parent?.id) return;\n    if(newParent && this.children.includes(newParent)) return;\n\n    if (this._parent) {\n      const transform = this._parent.getComponent(Transform);\n      const index = transform.children.indexOf(this.owner);\n      transform.children.splice(index, 1);\n    }\n    \n    this._parent = newParent;\n\n    if (this._parent) {\n      const transform = this._parent.getComponent(Transform);\n      transform.children.push(this.owner);\n    }\n\n    this.updateWorldMatrix();\n  }\n\n  public readonly children: Entity[] = [];\n\n  private readonly _position: Vector3;\n  public get position(): Vector3 { return this._position; }\n\n  private readonly _rotation: Vector3;\n  public get rotation(): Vector3 { return this._rotation; }\n\n  private readonly _scale: Vector3;\n  public get scale(): Vector3 { return this._scale; }\n\n  public readonly localMatrix: ObservableMatrix4 = new ObservableMatrix4();\n  public readonly worldMatrix: ObservableMatrix4 = new ObservableMatrix4();\n\n  constructor(owner: Entity, position?: Vector3, rotation?: Vector3, scale?: Vector3) {\n    super();\n\n    this.owner = owner;\n\n    this._position = position ?? Vector3.zero();\n    this._rotation = rotation ?? Vector3.zero();\n    this._scale = scale ?? Vector3.one();\n\n    this._position.x.subscribe(() => this.updateLocalMatrix());\n    this._position.y.subscribe(() => this.updateLocalMatrix());\n    this._position.z.subscribe(() => this.updateLocalMatrix());\n\n    this._rotation.x.subscribe(() => this.updateLocalMatrix());\n    this._rotation.y.subscribe(() => this.updateLocalMatrix());\n    this._rotation.z.subscribe(() => this.updateLocalMatrix());\n\n    this._scale.x.subscribe(() => this.updateLocalMatrix());\n    this._scale.y.subscribe(() => this.updateLocalMatrix());\n    this._scale.z.subscribe(() => this.updateLocalMatrix());\n\n    this.updateLocalMatrix();\n  }\n\n  public updateLocalMatrix(): void {\n    const t = vector3.fromValues(this._position.x.value, this._position.y.value, this._position.z.value);\n    const r = vector3.fromValues(this._rotation.x.value, this._rotation.y.value, this._rotation.z.value);\n    const s = vector3.fromValues(this._scale.x.value, this._scale.y.value, this._scale.z.value);\n\n    const q = quaternion.create();\n    quaternion.fromEuler(q, r[0], r[1], r[2]); // graus\n\n    const temp = matrix4.create();\n    this.localMatrix.value = matrix4.fromRotationTranslationScale(temp, q, t, s);\n    this.updateWorldMatrix();\n  }\n\n  public updateWorldMatrix(): void {\n    const parentTransform = this._parent?.getComponent(Transform);\n    if (parentTransform) {\n      const temp = matrix4.create();\n      matrix4.multiply(temp, parentTransform.worldMatrix.value, this.localMatrix.value);\n      this.worldMatrix.value = temp;\n    } else {\n      this.worldMatrix.value = matrix4.clone(this.localMatrix.value);\n    }\n\n    for (const childEntity of this.children) {\n      const childTransform = childEntity.getComponent(Transform);\n      childTransform?.updateWorldMatrix();\n    }\n  }\n\n\n  public setWorldMatrix(matrix: matrix4): void {\n    this.worldMatrix.value = matrix;\n\n    const inverseParent = this._parent?.getComponent(Transform).worldMatrix.value ?? matrix4.create();\n    const inv = matrix4.invert(matrix4.create(), inverseParent);\n    if (inv) {\n      matrix4.multiply(this.localMatrix.value, inv, matrix);\n    }\n\n    const t = vector3.create();\n    const r = quaternion.create();\n    const s = vector3.create();\n    matrix4.getTranslation(t, this.localMatrix.value);\n    matrix4.getRotation(r, this.localMatrix.value);\n    matrix4.getScaling(s, this.localMatrix.value);\n\n    const euler = vector3.create();\n    quatToEulerXYZ?.(euler, r);\n\n    this._position.set(t[0], t[1], t[2]);\n    this._rotation.set(euler[0], euler[1], euler[2]);\n    this._scale.set(s[0], s[1], s[2]);\n  }\n\n  public clone(): Transform {\n    const clone = new Transform(\n      this.owner,\n      this._position.clone(),\n      this._rotation.clone(),\n      this._scale.clone()\n    );\n    clone.enabled = this.enabled;\n    return clone;\n  }\n\n  public copyFrom(transform: Transform): void {\n    this._position.setFromVector(transform.position);\n    this._rotation.setFromVector(transform.rotation);\n    this._scale.setFromVector(transform.scale);\n  }\n\n  public toJSON() {\n    return {\n      enabled: this.enabled,\n      position: {\n        x: this._position.x.value,\n        y: this._position.y.value,\n        z: this._position.z.value,\n      },\n      rotation: {\n        x: this._rotation.x.value,\n        y: this._rotation.y.value,\n        z: this._rotation.z.value,\n      },\n      scale: {\n        x: this._scale.x.value,\n        y: this._scale.y.value,\n        z: this._scale.z.value,\n      },\n      parentId: this._parent?.id ?? null\n    };\n  }\n\n  public fromJSON(json: any): void {\n    this._parent = json.parent;\n    this.position.set(json.position.x, json.position.y, json.position.z)\n    this.rotation.set(json.rotation.x, json.rotation.y, json.rotation.z)\n    this.scale.set(json.scale.x, json.scale.y, json.scale.z)\n\n    this.enabled = json.enabled ?? true;\n  }\n\n  public destroy(): void {\n    this.children.length = 0;\n    this._parent = null;\n  }\n}\n\nfunction quatToEulerXYZ(out: vector3, q: quaternion): vector3 {\n  const x = q[0], y = q[1], z = q[2], w = q[3];\n  const xx = x * x, yy = y * y, zz = z * z;\n  const wx = w * x, wy = w * y, wz = w * z;\n  const xy = x * y, xz = x * z, yz = y * z;\n\n  const rx = -Math.atan2(2 * (yz - wx), 1 - 2 * (xx + yy));\n  const ry = Math.asin(Math.max(-1, Math.min(1, 2 * (xz + wy))));\n  const rz = -Math.atan2(2 * (xy - wz), 1 - 2 * (yy + zz));\n\n  const toDeg = 180 / Math.PI;\n  out[0] = rx * toDeg;\n  out[1] = ry * toDeg;\n  out[2] = rz * toDeg;\n  return out;\n}"
        }
      ]
    },
    {
      "name": "meshes",
      "children": [
        {
          "name": "cube.json",
          "content": "{\n  \"vertices\": [\n    -1.0, -1.0, 1.0,\n     1.0, -1.0, 1.0,\n     1.0,  1.0, 1.0,\n     1.0,  1.0, 1.0,\n    -1.0,  1.0, 1.0,\n    -1.0, -1.0, 1.0\n  ],\n  \"indices\": [\n    0, 1, 2,\n    2, 3, 0,\n\n    4, 5, 6,\n    6, 7, 4,\n\n    8, 9, 10,\n    10, 11, 8,\n\n    12, 13, 14,\n    14, 15, 12,\n\n    16, 17, 18,\n    18, 19, 16,\n\n    20, 21, 22,\n    22, 23, 20\n  ]\n}"
        },
        {
          "name": "quad.json",
          "content": "{\n  \"vertices\": [\n    -0.5, 0.0, -0.5,\n     0.5, 0.0, -0.5,\n    -0.5, 0.0,  0.5,\n     0.5, 0.0,  0.5\n  ],\n  \"indices\": [\n    0, 1, 2,\n    3, 2, 1\n  ]\n}\n"
        }
      ]
    },
    {
      "name": "systems",
      "children": [
        {
          "name": "interfaces",
          "children": [
            {
              "name": "awake.ts",
              "content": "import { Entity } from \"../../../core/api/entity\";\n\nexport interface IAwake { awake(entities: Entity[]): void }"
            },
            {
              "name": "fixedUpdate.ts",
              "content": "import { Entity } from \"../../../core/api/entity\";\n\nexport interface IFixedUpdate { fixedUpdate(entities: Entity[], fixedDeltaTime:number): void }"
            },
            {
              "name": "lateUpdate.ts",
              "content": "import { Entity } from \"../../../core/api/entity\";\n\nexport interface ILateUpdate { lateUpdate(entities: Entity[], deltaTime:number): void }"
            },
            {
              "name": "start.ts",
              "content": "import { Entity } from \"../../../core/api/entity\";\n\nexport interface IStart { start(entities: Entity[]): void }"
            },
            {
              "name": "system.ts",
              "content": "export interface ISystem {}"
            },
            {
              "name": "update.ts",
              "content": "import { Entity } from \"../../../core/api/entity\";\n\nexport interface IUpdate { update(entities: Entity[], deltaTime:number): void }"
            }
          ]
        },
        {
          "name": "orbitSystem.ts",
          "content": "import { ISystem } from \"./interfaces/system\";\nimport { Transform } from \"../components/transform\";\nimport { IUpdate } from \"./interfaces/update\";\nimport { Entity } from \"../../core/api/entity\";\nimport { Vector3 } from \"../../core/api/vector3\";\nimport { Orbit } from \"../components/orbit\";\n\nexport class OrbitSystem implements ISystem, IUpdate {\n    public update(entities: Entity[], deltaTime: number): void {\n      const orbitEntities = entities.filter(\n        (entity) => entity.hasComponent(Transform) && entity.hasComponent(Orbit)\n      );\n  \n      for (const entity of orbitEntities) {\n        const transform = entity.getComponent(Transform);\n        const orbit = entity.getComponent(Orbit);\n  \n        if (transform && orbit && orbit.enabled) {\n          orbit.angle.value += orbit.speed.value * deltaTime;\n          orbit.angle.value %= Math.PI * 2;\n  \n          const initial = new Vector3(orbit.distance.value, 0, 0);\n  \n          const rotated = initial.rotateAround(orbit.axis.normalize(), orbit.angle.value);\n          const position = orbit.center.add(rotated);\n  \n          transform.position.x.value = position.x.value;\n          transform.position.y.value = position.y.value;\n          transform.position.z.value = position.z.value;\n        }\n      }\n    }\n  }\n  "
        },
        {
          "name": "rotateSystem.ts",
          "content": "import { ISystem } from \"./interfaces/system\";\nimport { Transform } from \"../components/transform\";\nimport { Rotate } from \"../components/rotate\";\nimport { IUpdate } from \"./interfaces/update\";\nimport { Entity } from \"../../core/api/entity\";\n\nexport class RotateSystem implements ISystem, IUpdate {\n    public update(entities: Entity[], deltaTime: number): void {\n        const rotatingEntities = entities.filter(\n            (entity) => entity.hasComponent(Transform) && entity.hasComponent(Rotate)\n        );\n\n        for (const entity of rotatingEntities) {\n            const transform = entity.getComponent(Transform);\n            const rotate = entity.getComponent(Rotate);\n\n            if(transform && rotate) {\n                transform.rotation.x.value += rotate.speed.value * rotate.axis.x.value * deltaTime;\n                transform.rotation.y.value += rotate.speed.value * rotate.axis.y.value * deltaTime;\n                transform.rotation.z.value += rotate.speed.value * rotate.axis.z.value * deltaTime;\n            }\n        }\n    }\n}"
        }
      ]
    }
  ]
}