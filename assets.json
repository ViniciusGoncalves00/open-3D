{
  "name": "assets",
  "children": [
    {
      "name": "components",
      "children": [
        {
          "name": "component.ts",
          "content": "import { IObserver } from \"../../common/patterns/observer/observer\";\n\nexport abstract class Component {\n    public enabled: boolean = true;\n    public abstract clone(): Component;\n    public abstract copyFrom(component: Component): void;\n\n    private observers: IObserver[] = [];\n\n    public attach(observer: IObserver): void {\n        this.observers.push(observer);\n      }\n    \n    public dettach(observer: IObserver): void {\n      const index = this.observers.indexOf(observer);\n      if (index === -1) return;\n      this.observers.splice(index, 1);\n    }\n}"
        },
        {
          "name": "directional-light.ts",
          "content": "import { Vector3 } from \"../../core/api/vector3\";\nimport { Component } from \"./component\";\nimport { Light } from \"./light\";\n\nexport class DirectionalLight extends Light {\n    private readonly _direction: Vector3;\n    public get direction(): Vector3 { return this._direction; }\n\n    public constructor(color: string = \"0xffffff\", intensity: number = 1.0, direction: Vector3 = new Vector3(0, 0, 0)) {\n        super(color, intensity);\n\n        this._direction = direction;\n    }\n\n    public clone(): Component {\n        throw new Error(\"Method not implemented.\");\n    }\n    public copyFrom(component: Component): void {\n        throw new Error(\"Method not implemented.\");\n    }\n}"
        },
        {
          "name": "light.ts",
          "content": "import { Component } from \"./component\";\n\n/**\n* Abstract base class for lights.\n*/\nexport abstract class Light extends Component {\n    private _color: string;\n    private _intensity: number = 1.0;\n\n    /**\n    * @param color Light color (default: \"0xffffff\")\n    * @param intensity Light intensity (default: 1.0)\n    */\n    public constructor(color: string = \"0xffffff\", intensity: number = 1.0) {\n        super();\n\n        this._color = color;\n        this._intensity = intensity;\n    }\n}"
        },
        {
          "name": "mesh.ts",
          "content": "import { ObservableField } from \"../../common/patterns/observer/observable-field\";\nimport { Vector3 } from \"../../core/api/vector3\";\nimport { Component } from \"./component\";\n\nexport class Mesh extends Component {\n    private readonly _name: ObservableField<string>;\n    public get name(): ObservableField<string> { return this._name; }\n\n    private readonly _vertices: Vector3[];\n    public get vertices(): Vector3[] { return this._vertices; }\n\n    private readonly _indices: ObservableField<number>[];\n    public get indices(): ObservableField<number>[] { return this._indices; }\n\n    constructor(vertices: Vector3[] = [new Vector3(0, 0, 0), new Vector3(0, 0, 1), new Vector3(1, 0, 0)], indices: ObservableField<number>[] = [new ObservableField<number>(0), new ObservableField<number>(1), new ObservableField<number>(2)]) {\n      super();\n    \n      this._name = new ObservableField(\"TEST MESH NAME\");\n      this._vertices = vertices;\n      this._indices = indices;\n    }\n\n    public clone(): Component {\n        throw new Error(\"Method not implemented.\");\n    }\n    public copyFrom(component: Component): void {\n        throw new Error(\"Method not implemented.\");\n    }\n}"
        },
        {
          "name": "orbit.ts",
          "content": "import { ObservableField } from \"../../common/patterns/observer/observable-field\";\nimport { Vector3 } from \"../../core/api/vector3\";\nimport { Component } from \"./component\";\n\nexport class Orbit extends Component {\n  private readonly _center: Vector3;\n  public get center(): Vector3 { return this._center; }\n\n  private readonly _distance: ObservableField<number>;\n  public get distance(): ObservableField<number> { return this._distance; }\n\n  private readonly _speed: ObservableField<number>;\n  public get speed(): ObservableField<number> { return this._speed; }\n\n  private readonly _axis: Vector3;\n  public get axis(): Vector3 { return this._axis; }\n\n  public readonly _angle: ObservableField<number> = new ObservableField<number>(0);\n  public get angle(): ObservableField<number> { return this._angle; }\n\n  constructor(\n    center: Vector3 = new Vector3(0, 0, 0),\n    distance: ObservableField<number> = new ObservableField<number>(1),\n    speed: ObservableField<number> = new ObservableField<number>(1),\n    axis: Vector3 = new Vector3(0, 1, 0)\n  ) {\n    super();\n    this._center = center;\n    this._distance = distance;\n    this._speed = speed;\n    this._axis = axis;\n  }\n\n  public clone(): Component {\n    const clone = new Orbit(\n      this._center.clone(),\n      this._distance,\n      this._speed,\n      this._axis.clone()\n    );\n    clone.angle.value = this.angle.value;\n    clone.enabled = this.enabled;\n    return clone;\n  }\n\n  public copyFrom(orbit: Orbit): void {\n      this._center.set(orbit.center.x.value, orbit.center.y.value, orbit.center.z.value);\n      this._axis.set(orbit.axis.x.value, orbit.axis.y.value, orbit.axis.z.value);\n      this._distance.value = orbit.distance.value;\n      this._speed.value = orbit.speed.value;\n  }\n}"
        },
        {
          "name": "rotate.ts",
          "content": "import { Component } from \"./component\";\nimport { Vector3 } from \"../../core/api/vector3\";\nimport { ObservableField } from \"../../common/patterns/observer/observable-field\";\n\nexport class Rotate extends Component {\n  private readonly _axis: Vector3;\n  public get axis(): Vector3 { return this._axis; }\n\n  private readonly _speed: ObservableField<number>;\n  public get speed(): ObservableField<number> { return this._speed; }\n\n  constructor(axis: Vector3 = new Vector3(0, 0, 0), speed: ObservableField<number> = new ObservableField<number>(1)) {\n    super();\n    this._axis = axis;\n    this._speed = speed;\n  }\n\n  public clone(): Component {\n    const clonedAxis = new Vector3(this._axis.x.value, this._axis.y.value, this._axis.z.value);\n    const clone = new Rotate(clonedAxis, this._speed);\n    clone.enabled = this.enabled;\n    return clone;\n  }\n\n  public copyFrom(rotate: Rotate): void {\n      this._axis.set(rotate.axis.x.value, rotate.axis.y.value, rotate.axis.z.value);\n      this._speed.value = rotate.speed.value;\n  }\n}"
        },
        {
          "name": "transform.ts",
          "content": "import { Component } from \"./component\";\nimport { Vector3 } from \"../../core/api/vector3\";\n\nexport class Transform extends Component {\n  private readonly _position: Vector3;\n  public get position(): Vector3 { return this._position};\n\n  private readonly _rotation: Vector3;\n  public get rotation(): Vector3 { return this._rotation};\n\n  private readonly _scale: Vector3;\n  public get scale(): Vector3 { return this._scale};\n\n  constructor(position?: Vector3, rotation?: Vector3, scale?: Vector3) {\n    super();\n    \n    this._position = position ?? Vector3.zero();\n    this._rotation = rotation ?? Vector3.zero();\n    this._scale = scale ?? Vector3.one();\n  }\n\n  public clone(): Component {\n    const clonedPosition = new Vector3(this._position.x.value, this._position.y.value, this._position.z.value);\n    const clonedRotation = new Vector3(this._rotation.x.value, this._rotation.y.value, this._rotation.z.value);\n    const clonedScale = new Vector3(this._scale.x.value, this._scale.y.value, this._scale.z.value);\n    const clone = new Transform(clonedPosition, clonedRotation, clonedScale);\n    clone.enabled = this.enabled;\n    return clone;\n  }\n\n  public copyFrom(transform: Transform): void {\n      this._position.set(transform.position.x.value, transform.position.y.value, transform.position.z.value);\n      this._rotation.set(transform.rotation.x.value, transform.rotation.y.value, transform.rotation.z.value);\n      this._scale.set(transform.scale.x.value, transform.scale.y.value, transform.scale.z.value);\n  }\n}"
        }
      ]
    },
    {
      "name": "meshes",
      "children": [
        {
          "name": "cube.json",
          "content": "{\n  \"vertices\": [\n    -1.0, -1.0, 1.0,\n     1.0, -1.0, 1.0,\n     1.0,  1.0, 1.0,\n     1.0,  1.0, 1.0,\n    -1.0,  1.0, 1.0,\n    -1.0, -1.0, 1.0\n  ],\n  \"indices\": [\n    0, 1, 2,\n    2, 3, 0\n  ]\n}"
        },
        {
          "name": "quad.json",
          "content": "{\n  \"vertices\": [\n    -0.5, 0.0, -0.5,\n     0.5, 0.0, -0.5,\n    -0.5, 0.0,  0.5,\n     0.5, 0.0,  0.5\n  ],\n  \"indices\": [\n    0, 1, 2,\n    3, 2, 1\n  ]\n}\n"
        }
      ]
    },
    {
      "name": "systems",
      "children": [
        {
          "name": "interfaces",
          "children": [
            {
              "name": "awake.ts",
              "content": "import { Entity } from \"../../../core/api/entity\";\n\nexport interface IAwake { awake(entities: Entity[]): void }"
            },
            {
              "name": "fixedUpdate.ts",
              "content": "import { Entity } from \"../../../core/api/entity\";\n\nexport interface IFixedUpdate { fixedUpdate(entities: Entity[], fixedDeltaTime:number): void }"
            },
            {
              "name": "lateUpdate.ts",
              "content": "import { Entity } from \"../../../core/api/entity\";\n\nexport interface ILateUpdate { lateUpdate(entities: Entity[], deltaTime:number): void }"
            },
            {
              "name": "start.ts",
              "content": "import { Entity } from \"../../../core/api/entity\";\n\nexport interface IStart { start(entities: Entity[]): void }"
            },
            {
              "name": "system.ts",
              "content": "export interface ISystem {}"
            },
            {
              "name": "update.ts",
              "content": "import { Entity } from \"../../../core/api/entity\";\n\nexport interface IUpdate { update(entities: Entity[], deltaTime:number): void }"
            }
          ]
        },
        {
          "name": "orbitSystem.ts",
          "content": "import { ISystem } from \"./interfaces/system\";\nimport { Transform } from \"../components/transform\";\nimport { IUpdate } from \"./interfaces/update\";\nimport { Entity } from \"../../core/api/entity\";\nimport { Vector3 } from \"../../core/api/vector3\";\nimport { Orbit } from \"../components/orbit\";\n\nexport class OrbitSystem implements ISystem, IUpdate {\n    public update(entities: Entity[], deltaTime: number): void {\n      const orbitEntities = entities.filter(\n        (entity) => entity.hasComponent(Transform) && entity.hasComponent(Orbit)\n      );\n  \n      for (const entity of orbitEntities) {\n        const transform = entity.getComponent(Transform);\n        const orbit = entity.getComponent(Orbit);\n  \n        if (transform && orbit && orbit.enabled) {\n          orbit.angle.value += orbit.speed.value * deltaTime;\n          orbit.angle.value %= Math.PI * 2;\n  \n          const initial = new Vector3(orbit.distance.value, 0, 0);\n  \n          const rotated = initial.rotateAround(orbit.axis.normalize(), orbit.angle.value);\n          const position = orbit.center.add(rotated);\n  \n          transform.position.x.value = position.x.value;\n          transform.position.y.value = position.y.value;\n          transform.position.z.value = position.z.value;\n        }\n      }\n    }\n  }\n  "
        },
        {
          "name": "rotateSystem.ts",
          "content": "import { ISystem } from \"./interfaces/system\";\nimport { Transform } from \"../components/transform\";\nimport { Rotate } from \"../components/rotate\";\nimport { IUpdate } from \"./interfaces/update\";\nimport { Entity } from \"../../core/api/entity\";\n\nexport class RotateSystem implements ISystem, IUpdate {\n    public update(entities: Entity[], deltaTime: number): void {\n        const rotatingEntities = entities.filter(\n            (entity) => entity.hasComponent(Transform) && entity.hasComponent(Rotate)\n        );\n\n        for (const entity of rotatingEntities) {\n            const transform = entity.getComponent(Transform);\n            const rotate = entity.getComponent(Rotate);\n\n            if(transform && rotate) {\n                transform.rotation.x.value += rotate.speed.value * rotate.axis.x.value * deltaTime;\n                transform.rotation.y.value += rotate.speed.value * rotate.axis.y.value * deltaTime;\n                transform.rotation.z.value += rotate.speed.value * rotate.axis.z.value * deltaTime;\n            }\n        }\n    }\n}"
        }
      ]
    }
  ]
}